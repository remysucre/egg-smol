{
  "math-ast": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math))\n\n(define start (Add (Num 3) (Add (Num 4) (Var 42)))) ;; TODO typecheck this!\n(define goal  (Add (Num 7) (Var 42)))\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n\n(run 3)\n(check (= start goal))\n(extract start)\n",
  "interval": "(datatype Math\n  (Num rational)\n  (Var String)\n  (Mul Math Math))\n\n(function hi (Math) rational :merge (min old new))\n(function lo (Math) rational :merge (max old new))\n\n(rule ((= mul (Mul a b)))\n      ((set (lo mul) \n          (min (min (* (lo a) (lo b)) (* (lo a) (hi b)))\n               (min (* (hi a) (lo b)) (* (hi a) (hi b)))))))\n\n(define x (Var \"x\"))\n(define e (Mul x x))\n\n(set (lo x) -10//1)\n(set (hi x)  10//1)\n\n(run 1)\n\n(check (= (lo e) -100//1))\n\n(rule ((= mul (Mul a a)))\n      ((set (lo mul) (* (lo a) (lo a)))))\n\n(run 1)\n(check (= (lo e) 100//1))\n",
  "stratified": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n(check (path 1 2))\n\n(clear-rules)\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(edge 3 8)\n(run 1)\n(check (path 1 3))\n\n\n\n; Should fail\n; (check (path 1 4))\n; (check (path 3 8)) \n",
  "eqsolve": "(datatype Expr\n  (Add Expr Expr)\n  (Neg Expr)\n  (Num i64)\n  (Var String)\n)\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n(rule ((= (Add x y) z))\n      ((union (Add z (Neg y)) x)))\n(rewrite (Neg (Neg x)) x)\n(rewrite (Neg (Num n)) (Num (- 0 n)))\n;system 1: x + 2 = 7\n(set (Add (Var \"x\") (Num 2)) (Num 7))\n;system 2: z + y = 7, 2z = y\n(set (Add (Var \"z\") (Var \"y\")) (Num 7))\n(set (Add (Var \"z\") (Var \"z\")) (Var \"y\"))\n\n(run 3)\n(extract (Var \"x\"))\n(extract (Var \"y\"))",
  "pathproof": "; proofs of connectivity are paths\n(datatype Proof\n  (Trans i64 Proof)\n  (Edge i64 i64))\n\n; We enhance the path relation to carry a proof field\n(relation path (i64 i64 Proof))\n(relation edge (i64 i64))\n\n(edge 2 1)\n(edge 3 2)\n(edge 1 3)\n\n(rule ((edge x y))  \n      ((path x y (Edge x y))))\n(rule ((edge x y) (path y z p))  \n      ((path x z (Trans x p))))\n\n; We consider equal all paths tha connect same points.\n; Smallest Extraction will extract shortest path.\n(rule ((path x y p1) (path x y p2))  \n      ((union p1 p2)))\n\n(run 3)\n(check (path 3 1 (Trans 3 (Edge 2 1))))\n; Would prefer being able to check\n;(check (path 1 2 _))\n; or extract\n;(extract (path 1 4 ?p))",
  "unify": "(datatype Expr\n  (Mul Expr Expr)\n  (Var String)\n  (Lit i64)\n)\n\n; Assume injectivity of Mul for unification\n(rule ((= (Mul a b) (Mul c d)))\n      ((union a c)\n       (union b d)))\n\n;; (relation False (i64))\n; If any Literal make equal to something it can't be, false is derived\n;(rule ((= (Lit i) (Lit j)) (!= i j))\n;      ((False 0)))\n(rule ((= (Lit i) (Mul a b)))\n      ((panic \"Literal cannot be equal to a product\")))\n\n(set (Mul (Var \"a\") (Var \"a\")) \n     (Mul (Lit 1) (Lit 2)))\n\n\n(run 3)\n(check (= (Var \"a\") (Lit 1)))\n(check (= (Lit 2) (Lit 1)))\n; (check (False 0)) ;; this should fail because we don't want prove false",
  "points-to": "; Identifiers represented as strings, keep some newtypes around to aid clarity\n(datatype Class (Class String))\n(datatype Field (Field String))\n\n(datatype Stmt\n    (New String Class)\n    ; Assign dst src\n    (Assign String String)\n    ; Store dst field src\n    (Store String Field String)\n    ; Load dst src field\n    (Load String String Field))\n\n(relation VarPointsTo (String Class))\n(relation HeapPointsTo (Class Field Class))\n\n; New variables point to classes they're initialized as\n(rule ((= x (New a b))) ((VarPointsTo a b)))\n\n; If I assign v1 <- v2 and v2 points to a class c2, then v1 points to class c2\n; as well\n(rule ((= x (Assign v1 v2)) (VarPointsTo v2 c2))\n      ((VarPointsTo v1 c2)))\n\n; If c1.f points to c2, and v2 points to class c1, then assigning v1 <- v2.f\n; means v1 points to c2\n(rule ((= x (Load v1 v2 f)) \n       (VarPointsTo v2 c1)\n       (HeapPointsTo c1 f c2))\n      ((VarPointsTo v1 c2)))\n\n; If v1 points to class c1, and v2 to c2, and if v1.f <- v2, then c1.f points to\n; c2\n(rule ((= x (Store v1 f v2))\n       (VarPointsTo v1 c1)\n       (VarPointsTo v2 c2))\n      ((HeapPointsTo c1 f c2)))\n\n; Example in \"From Datalog to Flix\"\n; l1: ClassA o1 = new ClassA();\n; l2: ClassB o2 = new ClassB();\n; l3: ClassB o3 = o2;\n; l4: o2.f = o1;\n; l5: Object r = o3.f;\n\n(define A (Class \"A\"))\n(define B (Class \"B\"))\n(define f (Field \"f\"))\n\n(define l1 (New \"o1\" A))\n(define l2 (New \"o2\" B))\n(define l3 (Assign \"o3\" \"o2\"))\n(define l4 (Store \"o2\" f \"o1\"))\n(define l5 (Load \"r\" \"o3\" f))\n\n(run 3)\n\n(check (VarPointsTo \"o1\" A))\n(check (VarPointsTo \"o2\" B))\n\n(check (VarPointsTo \"o3\" B))\n(check (HeapPointsTo B f A))\n(check (VarPointsTo \"r\" A))",
  "primitives": "(check (= (+ 2 2)  4))\n(check (= (- 2 1)  1))\n(check (= (- 1 2) -1))",
  "path": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n        \n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n(check (path 1 4))",
  "typecheck": "; type checking for simply typed lambda calculus\n\n(datatype Type \n  (TUnit) \n  (TArr Type Type) ; t1 -> t2\n)\n\n(rule ( ; injectivity of ->\n  (= (TArr fr1 to1) (TArr fr2 to2))\n)(\n  (union fr1 fr2) (union to1 to2))\n)\n\n(datatype Expr \n  (Lam String Type Expr) ; lam x : t . e\n  (App Expr Expr) \n  (Var String) \n  (Unit)\n)\n\n(datatype Ctx \n  (Nil) \n  (Cons String Type Ctx)\n)\n\n; ctx |- expr : type\n(function typeof (Ctx Expr) Type)\n\n; ctx |- () : unit\n(rewrite (typeof ctx (Unit)) (TUnit))\n\n; ctx; x: t |- x : t\n(rewrite (typeof (Cons x t ctx) (Var x)) t)\n\n; ctx |- f :- t1 -> t2\n; ctx |- e : t1\n; -----------------\n; ctx |- f e : t2\n\n(rule (\n  (= (typeof ctx (App f e)) t2)\n)(\n  (union (typeof ctx f) (typeof ctx f))\n  (union (typeof ctx e) (typeof ctx e))\n))\n\n(rule (\n  (= (typeof ctx (App f e)) t)\n  (= (typeof ctx f) (TArr t1 t2))\n  (= (typeof ctx e) t1)\n)(\n  (union t t2)\n))\n\n; ctx |- x : t\n; ------------------ y != x \n; ctx; y: t |- x : t\n\n(rule ( ; creating demand to check ctx |- x : t\n  (= (typeof (Cons y ty ctx) (Var x)) t)\n  ; (!= x y) TODO disequality not supported yet\n)(\n  (union (typeof ctx (Var x)) (typeof ctx (Var x)))\n))\n\n(rule ( ; only check ctx; y: t |- x : t that has a demand\n    (= (typeof ctx (Var x)) t1)\n    (= (typeof (Cons y ty ctx) (Var x)) t2)\n    ; (!= x y) TODO disequality not supported yet\n)(\n    (union t1 t2)\n))\n\n; ctx; x: t1 |- e : t2\n; ------------------------------\n; ctx |- lam x: t1. e : t1 -> t2\n\n; rhs of rewrite creates demand\n(rewrite (typeof ctx (Lam x t1 e)) (TArr t1 (typeof (Cons x t1 ctx) e)))\n\n; TEST\n; ----\n\n; lam x : unit, f : unit -> unit . f x\n(define e \n  (Lam \"x\" (TUnit) \n       (Lam \"f\" (TArr (TUnit) (TUnit))\n            (App (Var \"f\") (Var \"x\")))))\n\n; lam x : unit . x\n(define id (Lam \"x\" (TUnit) (Var \"x\")))\n\n; (e () id) = ()\n(define t (typeof (Nil) (App (App e (Unit)) id)))\n\n(run 15)\n\n(check (= t (TUnit)))\n"
}